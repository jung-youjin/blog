---
layout: post
title: "임베디드시스템및실습 과정 중 생긴 궁금증 해결기"
author: youjin
tags: ["embeddedsw"]
image: ../img/embeddedsw2.png
date: "2021-04-17T01:48:37.121Z"
draft: false
---
## 04.17

<br />

🏃 <a>똥멍청이의 궁금증 해결기</a> 🏃

---

### Lab 5

<br />

> *stop*과 __END__ 사이에 쓰이는 저 코드의 정체는 뭐지?

분명 강의자료 / 이전 실습 자료에는 적혀있지 않던 것들이 추가되었다!
근데 찾아보니, 맨 처음 lab0 실습때도 이와 같은 3줄의 코드가 같은 위치에 적혀있더라...
분명 무슨 뜻이 있을텐데, 왜 교수님께서도, 조교님도 설명을 안해주시는걸까? 궁금했었는데 그냥 뭐 필요한건가보다~~ 하고 넘기다가,


```c
MOV r0, #0x18

LDR r1, =0x20026

SWI 0x123456
```

*lab5* 에서 문제점을 맞닥뜨렸다! **AXD Debugger**를 사용하는 우리는, *Step In*을 통해 한줄한줄 실행하며 레지스터의 변화값을 확인하고는 했는데,
이번 시간에 위 코드를 해당 위치에 넣고 돌렸더니, 실수로 *stop* 까지만 실행했어야 원하는 결과값을 r0 등에서 확인할 수 있었던 것을, **END** 까지 *Step In*해버리는 바람에,
우리가 r0에 할당되었던 값을 확인하지 못하고, 위 코드를 실행하는 바람에 r0에는 이미 #0x18이 들어가있어서, 실습 결과 화면 캡쳐를 잘못했던 것!!! :sob:

<br />

큰 실수하는 바람에 이와 같은 결과값이 나와도 되는지 그리고 실습은 위 코드 진행 전/ 후 어디까지 코드 실행해야하는지 도무지 몰라서, 조교님께 메일을 보냈었다.

#### 📧 stop 이후 코드는 c에서 return 0; 사용 의도와 같습니다. 자세한 사항은 수업시간 때 배우실 수 있을겁니다!

라는 답장을 받을 수 있었고, 덕분에
- 실습 코드 진행을 어디까지 해야하는지, 디버거를 어디서 멈춰야 하는지 이해할 수 있었고
- 정말 궁금했던 저 3줄 코드의 의미를 알 수 있었다 => return 0;

[조교님 메일 드린다고 찾아보고 참고한 해당 자료 관련 arm 공식사이트](https://www.keil.com/support/man/docs/ARMASM/armasm_dom1359731144051.htm)

<br />

한가지 해소하지 못한 궁금증이 있다면, __"*stop* 과 **END** 사이에 존재하는 코드로서 register에 할당함으로서 갖는 의미는 무엇인가?"__ 였는데, 거기까진 아직 이해를 하지 못했고, 시간 핑계로
마구마구 찾아보다 원하는 시원한 답변이 없어서 서치 포기를 했다... 다음번엔 제대로 알아내서 우리 조원들한테 공유해줘야지 😊

---

> Branch 명령어를 사용했는데 link register가 update된 이유?

**ENTRY** *start* *stop* **END** 총 4단계로 구성되는 ARM 코드의 수행 순서에서 우리는 지난번 `MOV ro, #0x18` 코드 진행을 막기 위해, 해당 코드들을 **주석 처리**하고 디버거에서 직접 실행했다
그랬던 이유는 주어진 과제가 loop를 굉장히 여러번 돌아야하는 구조였고, 일정 횟수 loop마다 변화하는 레지스터의 값을 직접 확인하고 싶기도 했고 + 그러나 끝까지 결과를 확인하려면 정말 많은 횟수의 *Step In*을
눌러야했기에 (그런데 **END**까지 커서가 넘어가지 않도록 주의해야했음,..) 귀찮아서 해당 코드를 그냥 주석처리하고 마구마구 끝날때까지 디버거 커서를 옮겼다...

<br />

### 그 결과...

<br />

분명 branch명령어에 condition만을 추가한 *BNE*, *BLE* 등을 사용했음에도 불구하고, **link register**값이 할당이 되는 현상을 발견하고 멘붕이 왔다... 아니 왜 분기하는데 r14가 쓰이는거야?!?! 😱
아무리 생각해도 말이 안되는 상황이었는데, 우리 중 똑똑한 친구가!!! 위에서 언급한 `return 0;` 을 주석 처리했기 때문에 ✨**인터럽트**✨ *stop* 을 가리키는 주소값이 **link register**에 할당되었고 말해주었다!!!
도대체, 그 놈의 리턴 0이 무엇이길래 말이야?!?! 하며, 구글에 굉장히 특수해보이는 이 hex 값 *0x123456* 을 검색해보니, 일부 내용 중 위 코드는 인터럽트를 없애주는 것이라며.... 0x18 관련? 이라면서 설명이 되어있었는데
사실 제대로 이해하지 못한 것 같다 ㅜㅜ Angel SWI.... Software Interrupt제어 관련인 것 같은데 아직 배우지 못해서 헷갈리고 어렵다....이건 다음에 글 쓸 때 알아오는 걸로~~~ 😘

<br />

~~P.S. 인터럽트라는 말만 들으면, 전에 인터럽트에 대한 질문을 받았을 때 어버어버 대답 못했던 악몽이 떠오른다... 아는 것도 모르는 너무 멍청했던 과거 (+지금)의 내가 너무 창피하다... 다신 그 실수 반복하지 않기 위해
이번에 임베 공부 열심히 해야지~~ 😭😭

---

> ARM에서 쓰이는 return 0; - Application termination


- 문제의 코드
      ```c
      ;exit code

      MOV r0, #0x18

      LDR r1, =0x20026

      SWI 0x123456
      ```

---


> 그래서 Angel SWI가 뭔데,,,?

...To be continued

<br />
