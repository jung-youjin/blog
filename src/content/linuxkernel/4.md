---
layout: post
title: "4강 - 프로세스 트리"
author: youjin
tags: ["linuxkernel"]
image: ../img/linuxpenguin2.png
date: "2020-04-14T18:06:00Z"
draft: false
---

4강) 2020.04.17 프로세스 트리 - 프로세스 상태와 프로세스 부모/자식 관계 자료구조

- 앞 내용 정리
    - thread_info구조체 안 task에 current 포인터에 대한 정보가 담겨있다
        - 이 구조체는 kernel stack의 마지막 아래 부분에 존재
    - sys_call()을 부를 때 안에 %esp(스택 포인터, 레지스터 위치) <- temporary 변수를 두어, 그 kernel stack의 위치가 담겨 있다
        - esp만 보고도 스택의 위치를 알 수 있다
            - esp는 커널 스택의 위치를 알려줌
- Process state

![file:///C:/Users/Friend/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg](file:///C:/Users/Friend/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg)

- new, ready, run, term, wait (일반적)
    - ready -> run) scheduler dispatch
    - run -> ready) interrupt
    - run -> wait) i/o or event wait
    - wait -> ready) i/o or event completion
    - run -> term) exit
    - new -> ready) admit
- 리눅스는 보통 서버용으로 제조 x
    - 메모리 없는 경우 생각하지 x
- 리눅스에서는 run과 ready를 구분하지 않는다 => 다 running으로 취급
    - 프로세스가 레디큐에 올라와 스케줄러가 선택하면 레디 큐에서 사라지지 않고 그대로 있는다. 있다가 wait 상태가 되서야 빠져나와 다른 곳으로 가게된다
        - 수행 중인지 아닌지는 커널이 구분하지 않는다
- I/O를 하기 위해 interruptible 상태로 바뀐다
    - 둘 다 i/o를 기다린다는 공통점이 있으나,
    - task_interruptible - 외부에서 시그널을 보내 i/o가 끝나지 않았음에도 running 상태로 옮길 수 있는 상태
        - 그 i/o는 다녀오면 주인이 없어 사라진다(중요하지 않은 것)
    - task_uninterruptible - i/o가 더 중요하게 느껴지는 경우, 외부 시그널에도 불구하고 계속 i/o를 기다린다
        - 단점) i/o가 망가진 경우, 계속 기다리는 데드락 상태
- __이 붙은 경우는 특수한 상태이다!
    - __TASK_TRACED
        - 디버깅 당하고 있는 상태
    - __TASK_STOPPED
        - 특수하게 임시로 정지된 상태
- 현재 프로세스 상태 조작
    - set_task_state(task, state);
        - task->state = state;
    - set_current_state(state); (위험하기 때문에 주로 자기 자신 상태를 바꾸는 경우가 많다)
        - set task state(current, state);
- Process context
    - System call 또는 exception 발생 상태
    - Process-context를 정의하는 이유
    - Interrupt가 발생해서 interrupt handler가 실행되는 상태는?
    - virtual memory 내 kernel과 user space로 나뉜다
        - kernel은 두가지로 나뉜다
            - interrupt 처리 (주로 HW에서 오는 정보)
            - system call 처리 (user space에서 오는 것들)
        - 1. interrupt 2. system call 3. user space
            - 1) interrupt context
                - interrupt 처리시 다른 interrupt stack 사용
                    - 개수: cpu 개수
            - 2,3) process context
                - process context안 user 사용시 user stack 사용
                    - 개수: 프로세스 개수
                - process context안 system call 처리시 kernel stack 사용
                    - 개수: 프로세스 개수
- The process family tree
    - 리눅스가 booting되면 가장 먼저 만들어지는 프로세스 : init
        - 이를 통해 다른 모든 프로세스들이 트리 형식으로 만들어지기 시작한다
        - parent, child를 가리키는 포인터 존재
    - init - PID가 1인 process, 모든 process들의 선조
    - 구조체 task_struct에서 tree 구성을 위한 pointer들
        - parent - 부모의 task_struct를 가리킴
            - `struct task_struct *my_parent - current-> parent;`
        - children - 자식의 task_struct list를 가리킴
            - 매크로를 주로 쓴다(list 구조)
            - ```
            - struct task_struct *task;
            - struct list_head *list;
            - list for_each(list, &current->children) {
                - task - list entry(list, struct task_struct, sibling);
            - }
            - ```
                - for문에서 dummy를 뺀 user들을 가리키도록 매크로가 만들어져 있다
                - list for each / list_entry 자주 보게 될 것!
                - list는 sibling을 가리키고 task는 전체 task 노드를 가리킨다
                - task - list entry parameter의 의미
                    - 1st) 가리키는 노드, 박스 (list)
                    - 2nd) 가리키는 구조체를 포함하는 구조체의 타입(task_struct)
                    - 3rd) task_struct 구조체 안에서 이 list가 가리키는 필드의 이름(sibling)
                    - => 이 부분 꼭 이해하기!
                - 기존의 linked list와 다르다!
                    - list header만 각각 다르게 붙여넣는 방식으로 쉽게 해결했다
        - circular list로 구성되어 처음과 끝이 연결되어 있다
        - node 앞 부분에 dummy가 존재한다
            - dummy의 역할)
